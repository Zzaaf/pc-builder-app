# PC Builder App

Ты разработчик в стартапе который разрабатывает веб-приложение для сборки компьютеров: `PC Builder App`. 
Это инструмент, который поможет пользователям создавать свои собственные компьютерные сборки с помощью удобного интерфейса. Оно позволяет пользователям выбирать различные компоненты, такие как процессор, материнскую плату, видеокарту, оперативную память и т.д., а затем сочетать их вместе, чтобы создать свою оптимальную конфигурацию компьютера. 

Твоя задача с нуля написать базовый функционал по ТЗ, чтобы по итогу сделать клиентский билд. 
Этот билд нужно будет использовать как статические файлы на HTTP сервере.

## Release 0. Установка необходимых пакетов

Первым делом нужно определиться какие пакеты тебе нужны. Заметь файлов `package.json` и `package-lock.json` нет, и тебе нужно определить назначение каждого пакета. Одно точно известно, что используется `React`, остальное нужно установить в зависимости от задач. Твой тимлид предлагает тебе использовать сборщик [Vite](https://vitejs.dev/) и проинициализировать проект в папке `client`, так как в будущем появится отдельная папка `server`.

## Release 1. Создание клиентской структуры проекта

Когда папка `client` сформирована и в ней есть уже базовая структура от `Vite`, изучи эту структуру так как она поможет тебе лучше ориентироваться в любом другом проекте. После запуска скрипта: `npm run dev` запустится клиентский код в браузере, который готов к дальнейшим изменениям.
Соответственно изначальная структура будет изменяться под нужды задачи. 

Это означает что в папку `src` нужно будет добавлена папка `App`, которая будет отвечать за всё приложение в целом. На одном уровне c папкой `App` частым решением является создание папки `features`, которая будет хранилищем основных компонентов с логикой.

Помни что ты разрабатываешь приложение для сборки компьютера наименование папок/компонентов должно быть соответствующее.

Список основных сущностей:
- профиль (объект с ключами: `name`, `email`, `avatar`)
- сборка/продукт (объект с ключами которые соответствую модулю), создаёт клиент в любом количестве
- модуль (объект, составляющая часть для сборки/продукта)
- список сборок (массив, пополняется когда создаётся новая сборка, изначально пустой)

Пример демонстрационной сборки заглушки:
```javascript
    const demoProduct = {
      id: 1,
      title: 'Untitled', 
      processor: 'none', 
      motherboard: 'none',
      cpuCooler: 'none',
      case: 'none',
      graphicsCard: 'none',
      ram: 'none', 
      storage: 'none',
      caseCooler: 'none',
      powerSupply: 'none',
    }
```

По итогу должна получится структура папок и файлов которые будут использоваться в приложении.

## Release 2. Клиентская маршрутизация с помощью React Router

Когда базовая структура файлов и папок готовы, нужно разобраться с клиентской маршрутизацией и определить компоненты на заланные маршруты. Для этого используй пакет: [React Router DOM](https://www.npmjs.com/package/react-router-dom) и его [документацию](https://reactrouter.com/en/main)

Реализовать нужно три основных маршрута:
- `/`: отображает компонент Home, где можно создать сборку
- `/profile`: отображает компонент Profile, где можно будет указать данные текущего пользователя
- `/products`: отображает компонент ProductList, список всех сборок
- `/products/:id`: отображает компонент CurrentProduct, конкретная сборка

Разберись со встроенными в библиотеку React Router DOM компонентами:

- `<BrowserRouter>`
- `<Routes>`
- `<Route>`
- `<Link>`

Итогом релиза должен быть компонент `<Nav>` который создаёт навигацию по ранее реализованным компонентам приложения.

Пример кода:

```javascript
<BrowserRouter>
   <Nav/>
   <Routes>
      <Route path="/" element = {<Home />} />
      <Route path="/profile" element = {<Profile/>} />
      <Route path="/products" element = {<ProductList />} />
      <Route path="/products/:id" element = {<CurrentProduct />} />
   </Routes>      
</BrowserRouter>
```

## Release 3. Профиль

Компонент `Profile` описывает UI для: 
- ввода имени
- ввода email
- выбора типа аватарки (робот, человек, фигуры и т.д.)

Типов аватарки должно быть минимум 3 (реализация через HTML тег `option`).
Тимлид предлагает использовать для этого API: https://avatars.dicebear.com

`Важно! Разобраться с документацией сторонней API нужно самостоятельно!`

## Release 4. Создание нового модуля

Теперь у тебя есть клиентская маршрутизация которая позволяет пользователю видеть разные разделы приложения.
Одним из главных разделов будет `/`, стартовая точка которая позволяет создавать сборку компьютера.

Тимлид поставил задачу сделать специальную кнопку `Add new build` по центру экрана, при клике по ней должно происходить наполнение состояния. Обычно состоянием выступает массив, который наполняется объектами. Проверь подходит ли тебе такой вариант работы с состоянием?

Пример наполнения состояния:

Состояние до клика по кнопке `Add new build`: 
```javascript
[]
```

Состояние после клика по кнопке `Add new build`: 
```javascript
[
   {
   
      id: 1,
      title: 'Untitled', 
      processor: 'none', 
      motherboard: 'none',
      cpuCooler: 'none',
      case: 'none',
      graphicsCard: 'none',
      ram: 'none', 
      storage: 'none',
      caseCooler: 'none',
      powerSupply: 'none',
   }
]
```

Чтобы удобнее изучать работу React приложений тимлид что-то говорил про рассширение браузера Chrome: [React Developer Tools](https://chromewebstore.google.com/detail/fmkadmapgofadopljbjfkapdkoienihi), посмотри как он работает. 
В панели разработчика браузера должны появится две новые вкладки `Components` и `Profiler`, они отображают свойства всех компонентов и инструменты для отладки.

Корректная работа кнопки `Add new build` в твоём случае это количество объектов в массиве равно количеству кликов. Так же тимлид просил обратить внимание чтобы ключ `id` каждой сборки был уникален, и использовался в атрибуте `key`. Для генерации уникального ключа можно использовать сторонюю библиотеку [UUID](https://www.npmjs.com/package/uuid).

Пример использования библиотеки:
```typescript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
```

## Release 5. Отображение списка сборок/продукта

Основная задача этого релиза добиться отображения списка всех сборок/продуктов, это те сущности которые были ранее добавлены через кнопку `Add new build`.

Первым делом разберись как вообще формируются списки в React, как в них применяются атрибуты `key`?

Пример рендера простого списка:
```typescript
import React from 'react';
import ProductItem from '../ProductItem/ProductItem';

function Products({ products }) {
  return (
    <>
      <h1>Products</h1>

      <section className="d-flex">
        {products.length ? products.map((el) => <ProductItem key={el.id} product={el} />) : <h3>No data</h3>}
      </section>
    </>
  );
}

export default Products;
```

## Release 6. Редактирование сборки/продукта

Конечно же твоему приложению нужен функционал редактирования сборок/продуктов и его реализация связана с библиотекой [React Router DOM](https://www.npmjs.com/package/react-router-dom) с которой уже велась работа во 2-ом релизе.

Чтобы редактировать конкретную сборку/продукт нам нужно на самой карточке сборки создать копку `Edit`, которая будет вести на страницу редактирования.

Пример алгоритма действий:
- Есть рендер списка, например 10 элементов
- В каждом элементе списка есть кнопка `Edit`
- Если мы кликаем на `Edit` 5-ой карточки локация перехода (адресная строка в браузере) должна быть: `/products/5`
- Для адреса: `/products/5` должен отрендериться соответствующий компонент, в котором будет форма для редактирования сборки/продукта с кнопкой `Save`, используй хук `useParams` для получения параметра `5` в компоненте редактирования
- Кликая по кнопке `Save` данные карточки 5 меняются на те, которые были в форме и клиент возвращается на адрес: `/products`

## Release 7. Удаление сборки/продукта

Последней CRUD-операцией будет удаление, которое будет реализовано через клик по кнопке `Delete`, эта кнопка должна быть рядом с кнопкой `Edit`. После клика страница не перезагружается, но количество сборок/продуктов уменьшается на 1.

## Release 8. Создание серверной структуры проекта*

Этот релиз со здёздочкой, так как основная его задача добавить серверный код к нашему клиентскому приложению. На данный момент вся разработка велась в папке `clinet`, теперь на этом же уровне добавляется папка `server`, где необходимо написать минимальный HTTP-сервер.

Что нужно реализовать:
- установить необходимые серверные пакеты: `Express`
- создать файл конфигурации сервера `config/serverConfig.js`
- применить файл конфигурации в `app.js`
- убедиться что сервер работает корректно на 3000 порту

## Release 9. Назначение статики*

Последний релиз заключается в том, чтобы создать с помощью сборщика `Vite` билд (команда `npm run build`), который нужно использовать как статическую папку для сервера. 
В итоге когда сервер будет получать запрос на `/`, ответом должен быть `index.html` файл входящий в состав папки `dist`. В `index.html` уже автоматически будут подключены все необходимые скрипты и стили. 